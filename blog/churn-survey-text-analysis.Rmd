---
date: 2017-07-05T15:57:50-04:00
author: Julian Winternheimr
type: "post"
tags: []
title: "Why Users Churn"
---

People decide to leave or stop paying for Buffer. It's unfortunate, but it happens for one reason or another. 

We collect a lot of data from these users in the form of churn surveys. It might be beneficial to analyze the text of these survey comments to see if we can learn anything new.

## Data collection
The data we'll use in this analysis comes from [this look](https://looker.buffer.com/looks/3949) and will be imported with the `get_look()` function from the `buffer` package.

```{r include = FALSE}
library(buffer); library(dplyr); library(ggplot2); library(tidytext)
```

```{r}
# Get churn responses
responses <- get_look(3949)
```

Now let's clearn the data a bit.

```{r}
# Rename columns
colnames(responses) <- c('created_at', 'user_id', 'type', 'reason', 'specifics', 'details')

# Set strings as character type
responses$details <- as.character(responses$details)

# Remove the respon and specifics columns
responses$reason <- NULL
responses$specifics <- NULL
```

Alright, now we're ready to tidy the data.

## Data tidying
Here is some context on the idea of tidy data taken from the book Tidy Text Mining with R: 

> Using tidy data principles is a powerful way to make handling data easier and more effective, and this is no less true when it comes to dealing with text. As described by Hadley Wickham (Wickham 2014), tidy data has a specific structure:
 - Each variable is a column
 - Each observation is a row
 - Each type of observational unit is a table

We thus define the tidy text format as being a table with one-token-per-row. A token can be a word or an n-gram. Within our tidy text framework, we need to both break the comments into individual tokens and transform it to a tidy data structure. To do this, we use tidytext’s `unnest_tokens()` function. This breaks the NPS comments into individual words and includes one word per row while retaining the attributes (segment, user_id, etc) of that word.

```{r}
# Unnest the tokens
text_df <- responses %>%
  unnest_tokens(word, details)
```

Now that the data is in one-word-per-row format, we can manipulate it with tidy tools like `dplyr`. Often in text analysis, we will want to remove stop words; stop words are words that are not useful for an analysis, typically extremely common words such as “the”, “of”, “to”, and so forth in English. We can remove stop words (kept in the tidytext dataset stop_words) with an `anti_join()`.

```{r}
# Collect stop words
data(stop_words)

# Remove stop words from our dataset with an anti_join()
text_df <- text_df %>%
  anti_join(stop_words, by = "word")
```

Great! I think we've got a tidy data frame now.

## Data exploration
Let's take a moment here to see the most common words overall from the churn surveys.

```{r}
# Find most common words
text_df %>%
  count(word, sort = TRUE) %>%
  filter(n > 100) %>%
  mutate(word = reorder(word, n)) %>%
  ggplot(aes(word, n)) +
  geom_col() +
  labs(x = "", y = "", title = "Most Common Words") + 
  coord_flip()
```

It's interesting to see "plan" used so frequently. Words like "post", "time", and "facebook" may be possible signals as well. It's really interesting to see "love" in there as well.

Ok, now do words occur more frequently in the business churn survey?

To find this out, we can calculate the relative frequency of words that appear in the business churn survey and compare that to the relative frequency of the words in the other surveys.

```{r echo = FALSE}
library(tidyr)

# Calculate relative frequency of words
frequency <- text_df %>%
  filter(!(is.na(type)) & type != "") %>%
  count(type, word) %>%
  group_by(type) %>%
  mutate(proportion = n / sum(n)) %>% 
  select(-n) %>% 
  spread(type, proportion) %>% 
  gather(segment, proportion, 
         c(awesome_downgrade_survey, business_downgrade_awesome_survey:exit_survey))

# Replace NA with 0
frequency[is.na(frequency)] <- 0
```


```{r warning = F, message = F, echo = FALSE}
library(scales)

# Expect a warning about rows with missing values being removed
ggplot(frequency, aes(x = proportion, y = business_churn_survey, 
                      color = abs(business_churn_survey - proportion))) +
  geom_abline(color = "gray40", lty = 2) +
  geom_jitter(alpha = 0.1, size = 2.5, width = 0.3, height = 0.3) +
  geom_text(aes(label = word), check_overlap = TRUE, vjust = 1.5) +
  scale_x_log10(labels = percent_format()) +
  scale_y_log10(labels = percent_format()) +
  scale_color_gradient(limits = c(0, 0.001), low = "darkslategray4", high = "gray75") +
  facet_wrap(~segment, ncol = 2) +
  theme(legend.position="none") +
  labs(y = "Business Churn Survey", x = "")
```

Words that are close to the line in these plots have similar frequencies in both sets of comments. For example, in both the business churn survey and the awesome downgrade survey, “account”, “access”, and “afford” are used frequently. 

Words that are far from the line are words that are found more in one set of comments than another. Words on the left side of the dotted line occur more frequently in the business churn survey's comments than in the other surveys. For example, in the `awesome_downgrade_survey` panel, words like "expensive", "99", and "analytcs" are much more common in the business churn survey than in the awesome survey.

## Analyzing word frequency
It may be useful to also see words that appear more frequently for certain segments of users. To do that, we can a term's _inverse document frequency (tdf)_, defined as: 

` idf(term) = ln(documents / documents containing term)`

> The statistic tf-idf is intended to measure how important a word is to a document in a collection (or corpus) of documents, for example, to one novel in a collection of novels or to one website in a collection of websites.

Let's calculate the term frequencies in our surveys for each segment of responders.

```{r}
# Calculate the frequency of words for each segment
segment_words <- text_df %>%
  count(type, word, sort = TRUE) %>%
  ungroup()

# Calculate the total number of words for each segment
total_words <- segment_words %>% 
  group_by(type) %>% 
  summarize(total = sum(n))

# Join the total words back into the segment_words data frame
segment_words <- left_join(segment_words, total_words, by = "type") %>%
  filter(type != "")

# View data 
head(segment_words)
```

There is one row in this data frame for each word-segment combination. `n` is the number of times that word is used for that segment and total is the total number of words in the segment's comments. 
## The `bind_tf_idf` function
The idea of tf-idf is to find the important words for the content of each collection of comments by decreasing the weight for commonly used words and increasing the weight for words that are not used very much in an entire collection of documents, in this case all NPS comments.

> Calculating tf-idf attempts to find the words that are important (i.e., common) in a text, but not too common.

The `bind_tf_idf` function takes a tidy text dataset as input with one row per token (term), per document. One column (`word` here) contains the terms/tokens, one column contains the documents (`segment` here), and the last necessary column contains the counts, how many times each document contains each term (`n`). 

```{r}
# Calculate tf_idf
segment_words <- segment_words %>%
  bind_tf_idf(word, type, n)

segment_words
```

The `idf` and `tf_idf` will be 0 for extremely common words like "the" and "a". We've already removed these stop words from our dataset.

Let's look at words with high `tf_idf` values.

```{r}
# Look at high tf_idf value words
segment_words %>%
  select(-total) %>%
  arrange(desc(tf_idf))
```

Now let's visualize these high `tf_idf` words for each segment of responders.

```{r warning = F, message = F, echo = FALSE}
# Tidy the words
plot_words <- segment_words %>%
  arrange(desc(tf_idf)) %>%
  mutate(word = factor(word, levels = rev(unique(word))))

# Create the plot
plot_words %>% 
  group_by(type) %>% 
  top_n(10) %>% 
  ungroup %>%
  ggplot(aes(word, tf_idf, fill = type)) +
  geom_col(show.legend = FALSE) +
  labs(x = NULL, y = "tf-idf") +
  facet_wrap(~type, ncol = 2, scales = "free") +
  coord_flip()
```

The words that appear in these graphs appear more frequently in the specific survey type than they do in the other surveys. I think we can ignore "buffer". The word "plan" seems to appear often in each survey _except_ the exit survey as well.

It seems competitors are mentioned most frequently in the business churn survey. We don't have much context and are required to speculate on what the meaning and emotion behind the words might be. 

It may be beneficial to look at groups of words to help us gather more information. :) 

## N-grams
What if we looked at groups of words instead of just single words? We can check which words tend to appear immediately after another, and which words tend to appear together in the same document.

We’ve been using the `unnest_tokens` function to tokenize by word, but we can also use the function to tokenize into consecutive sequences of words, called n-grams. By seeing how often word X is followed by word Y, we can then build a model of the relationships between them.

We do this by adding the `token = "ngrams"` option to `unnest_tokens()`, and setting `n` to the number of words we wish to capture in each n-gram. When we set `n` to 2, we are examining groups of 2 consecutive words, often called “bigrams”:

```{r}
# Unnest bigrams from responses
bigrams <- responses %>%
  unnest_tokens(bigram, details, token = "ngrams", n = 2)

# View the bigrams
head(bigrams$bigram)
```

Great! Each token now is represented by a bigram. Let's take a quick look at the most common bigrams

```{r}
# Count the most common bigrams
bigrams %>%
  count(bigram, sort = TRUE)
```

As we might expect, a lot of the most common bigrams are groups of common words. This is a useful time to use tidyr’s `separate()`, which splits a column into multiple based on a delimiter. This lets us separate it into two columns, “word1” and “word2”, at which point we can remove cases where either is a stop-word.

```{r}
# Separate words in bigrams
separated <- bigrams %>%
  separate(bigram, c("word1", "word2"), sep = " ")

# Define our own stop words
word <- c("i", "i'm", "it", "the", "at", "to", "right", "just", "to", "a", "an",
          "that", "but", "as", "so", "will", "for", "longer", "i'll", "of", "my",
          "n", "do", "did", "am", "with", "been", "and", "we")

# Create tibble of stop words
stopwords <- tibble(word)

# Filter out stop-words
filtered <- separated %>%
  filter(!word1 %in% stopwords$word) %>%
  filter(!word2 %in% stopwords$word)

# Calculate new bigram counts
bigram_counts <- filtered %>% 
  count(word1, word2, sort = TRUE)

bigram_counts
```

In other analyses, we may want to work with the recombined words. tidyr’s `unite()` function is the inverse of separate(), and lets us recombine the columns into one. 

```{r}
# Reunite the words
bigrams_united <- filtered %>%
  unite(bigram, word1, word2, sep = " ")

head(bigrams_united$bigram)
```

Nice! Let's look at the most common bigrams.

```{r}
# Find most common bigrams
bigrams_united %>%
  count(bigram, sort = TRUE)
```

A bigram can also be treated as a term in a document in the same way that we treated individual words. For example, we can look at the tf-idf of these trigrams across the surveys. These tf-idf values can be visualized within each segment, just as we did for words earlier.

```{r echo = FALSE}
# Calculate tf_idf
bigram_tf_idf <- bigrams_united %>%
  count(type, bigram) %>%
  bind_tf_idf(bigram, type, n) %>%
  arrange(desc(tf_idf))
```

```{r echo = FALSE, message = FALSE, warning = FALSE}
# Tidy the bigrams
plot_bigrams <- bigram_tf_idf %>%
  arrange(desc(tf_idf)) %>%
  mutate(bigram = factor(bigram, levels = rev(unique(bigram))))

# Create the plot
plot_bigrams %>% 
  group_by(type) %>% 
  top_n(10) %>% 
  ungroup %>%
  ggplot(aes(reorder(bigram, tf_idf), tf_idf, fill = type)) +
  geom_col(show.legend = FALSE) +
  labs(x = NULL, y = "tf-idf") +
  facet_wrap(~type, ncol = 2, scales = "free") +
  coord_flip()
```

I'm seeing a lot of people just not using or not needing Buffer. 

We may want to visualize the relationship between these bigrams, instead of just listing the most common ones.

## Visualizing a network of bigrams with ggraph
As one common visualization, we can arrange the words into a network, or “graph.” Here we’ll be referring to a “graph” not in the sense of a visualization, but as a combination of connected nodes. A graph can be constructed from a tidy object since it has three variables:

 - from: the node an edge is coming from
 - to: the node an edge is going towards
 - weight: A numeric value associated with each edge
 
The `igraph` package has many powerful functions for manipulating and analyzing networks. One way to create an igraph object from tidy data is the `graph_from_data_frame()` function, which takes a data frame of edges with columns for “from”, “to”, and edge attributes (in this case n):

```{r warning = F, message = F}
library(igraph)

# Original counts
bigram_counts
```

Let's create a bigram graph object.

```{r}
# filter for only relatively common combinations
bigram_graph <- bigram_counts %>%
  filter(n > 25) %>%
  graph_from_data_frame()

bigram_graph
```

We can convert an igraph object into a ggraph with the ggraph function, after which we add layers to it, much like layers are added in ggplot2. For example, for a basic graph we need to add three layers: nodes, edges, and text.

```{r echo = FALSE}
library(ggraph)
set.seed(2017)

# Creage ggraph of bigrams
ggraph(bigram_graph, layout = "fr") +
  geom_edge_link() +
  geom_node_point() +
  geom_node_text(aes(label = name), vjust = 1, hjust = 1)
```

We can use this graph to visualize some details about the text structure. For example, we can see that "buffer", "customer", "media", and "time" form the centers of groups of nodes. We also see pairs or triplets along the outside that form common short phrases ("reasonable price", "calendar view", or "free version").

Let's add some polish to this graph that might make it easier to interpret.

```{r echo = FALSE}
# Set seed for reproducible graph
set.seed(2017)

# Set the error features
a <- grid::arrow(type = "closed", length = unit(.1, "inches"))

# Create the graph
ggraph(bigram_graph, layout = "fr") +
  geom_edge_link(aes(edge_alpha = n), show.legend = F, arrow = a, end_cap = circle(.07, 'inches')) +
  geom_node_point(color = "lightblue", size = 3) +
  geom_node_text(aes(label = name), vjust = 1, hjust = 1) +
  theme_void()
```

This is a visualization of a **Markov chain**, a model in text processing. In a Markov chain, each choice of word depends only on the previous word. In this case, a random generator following this model might spit out "buffer", then "is", then "great", by following each word to the most common words that follow it. To make the visualization interpretable, I chose to show only the most common word to word connections. What can we learn from this graph? 

I see that "don't" is at the center of a cluster of nodes. These include the phrases "don't need", "don't use", and "don't have". There are also isolated clusters referencing the cost, e.g. "can't afford" and "too expensive". There is also a cluster referring to users that will come back.

What would this graph look like if we only looked at the responses of the _business_ churn survey?

```{r echo = FALSE}
# Calculate new bigram counts for the business customers
business_counts <- filtered %>% 
  filter(type == "business_churn_survey") %>%
  count(word1, word2, sort = TRUE)

# Filter for only relatively common combinations
business_graph <- business_counts %>%
  filter(n > 2) %>%
  graph_from_data_frame()

# Set seed for reproducible graph
set.seed(2016)

# Set the error features
a <- grid::arrow(type = "closed", length = unit(.1, "inches"))

# Create the graph
ggraph(business_graph, layout = "fr") +
  geom_edge_link(aes(edge_alpha = n), show.legend = F, arrow = a, end_cap = circle(.07, 'inches')) +
  geom_node_point(color = "lightpink", size = 3) +
  geom_node_text(aes(label = name), vjust = 1, hjust = 1) +
  theme_void()
```

There are similar themes in this graph. Users simply aren't using, or don't need, Buffer. Cost is mentioned, as well as refunds. Sprout social is mentioned, as well as set up. Interestingly "come back" and "thank you" are also present. 

## Conclusions
Based on these Markov chains, it feels important to figure out why users stop using and needing Buffer. In many cases it could be due to external factors like business needs, market forces, layoffs, but in other cases it could be due to Buffer itself. Perhaps Buffer could have a better engagement loop. Or perhaps Buffer could help users that become inactive by suggesting content to share.

Another theme that appears repeatedly is cost. We know that the current pricing structure isn't completely ideal, so it feels good to be working towards a more individualized structure over the next few product cycles. 

There is a general theme of gratitude in these responses - "i love buffer" was a common phrase that appeared often in each survey. It's comforting to know that people like the product and team -- I hope that we'll be able to use some of these learnings to give them a better experience. :) 
